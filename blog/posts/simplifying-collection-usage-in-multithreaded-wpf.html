<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<link rel="icon" href="../../favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		
		<link href="../../_app/immutable/assets/0.PNHaEdqi.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/4.CwiAQOES.css" rel="stylesheet">
		<link rel="modulepreload" href="../../_app/immutable/entry/start.CRnMxn2k.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/CROONeqP.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/CYEMZujY.js">
		<link rel="modulepreload" href="../../_app/immutable/entry/app.Bm8EiCMo.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/abmEAOcE.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/0.vmpD8PAU.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/Ch112KOa.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/CIAdVOhT.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/4.C9_qBJei.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/sbWH3_uq.js"><title>Simplifying Collection Usage in Multithreaded WPF | Tad McCorkle</title><!-- HEAD_svelte-1eytxyh_START --><meta name="description" content="A personal website and blog by Tad McCorkle."><link rel="canonical" href="https://tadmccorkle.com/blog/posts/simplifying-collection-usage-in-multithreaded-wpf"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Tad McCorkle's Blog Feed"><link rel="sitemap" type="application/xml" title="Tad McCorkle - Sitemap" href="/sitemap.xml"><meta name="author" content="Tad McCorkle"><meta property="og:locale" content="en_US"><meta property="og:title" content="Tad McCorkle"><meta property="og:description" content="A personal website and blog by Tad McCorkle."><meta property="og:url" content="https://tadmccorkle.com/"><meta property="og:site_name" content="Tad McCorkle"><!-- HEAD_svelte-1eytxyh_END --><!-- HEAD_svelte-8dgaa3_START --><meta property="og:type" content="article"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"><!-- HEAD_svelte-8dgaa3_END -->
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">   <header><nav class="svelte-1bzmvou"><a href="/" class="home svelte-1bzmvou" data-svelte-h="svelte-phga3q">TM</a> <div><a href="/about" class="nav-link svelte-1bzmvou" data-svelte-h="svelte-xnd6pu">About</a> <a href="/projects" class="nav-link svelte-1bzmvou" data-svelte-h="svelte-1pcicv8">Projects</a> <a href="/" class="nav-link svelte-1bzmvou" data-svelte-h="svelte-hx5xq1">Blog</a></div></nav> </header> <main class="svelte-17szv2b"> <article class="svelte-cugkhp"><h1 id="post-title" class="svelte-cugkhp">Simplifying Collection Usage in Multithreaded WPF</h1> <small id="post-meta" class="svelte-cugkhp">posted on May 12, 2025</small>  <!-- HTML_TAG_START --><p>Data binding in WPF makes updating the UI in response to changes easy, so long as the UI is notified of changes by way of the <code>INotifyPropertyChanged</code> or <code>INotifyCollectionChanged</code> interface change events. For scalar properties, this is true even when an update is triggered from a background thread — the binding engine handles the property change by marshalling it (i.e., queuing a corresponding delegate) to the appropriate UI thread's dispatcher. While there's no manual marshalling or synchronization required by the application developer for scalar property updates, you'll quickly discover that this is <strong>not</strong> the case when binding an <code>ItemControl</code>'s <code>ItemsSource</code> to a dynamic collection. In fact, manual marshalling to the UI thread or additional synchronization is absolutely required in a multithreaded context.</p>
<aside><p><strong>tl;dr</strong> I've been using <a href="#my-preferred-solution">a simple solution</a> to the issue of multithreaded collection modification in WPF that avoids many of the tradeoffs in approaches I've seen referenced. You can see it in action <a href="https://github.com/tadmccorkle/CsmLib">here</a>.</p></aside>
<h1 id="why-are-collections-treated-differently"><a aria-hidden="true" tabindex="-1" href="#why-are-collections-treated-differently"><span class="icon icon-link"></span></a>Why are collections treated differently?</h1>
<p>Without getting too deep in the weeds, this is due to how WPF handles collection bindings. WPF uses a type called <code>CollectionView</code> to access a bound collection. Any given <code>CollectionView</code> has affinity to the thread that created its corresponding <code>ItemsControl</code>, meaning it requires its operations to occur on that thread. By default, if a <code>CollectionView</code> operation is initiated from a background thread — for example, by adding to a UI-bound <code>ObservableCollection&#x3C;T></code> — the <code>CollectionView</code> will throw an exception.</p>
<p>Notice I said this <code>CollectionView</code> behavior is "by default." WPF does provide a mechanism to allow collection changes on background threads through <code>BindingOperations.EnableCollectionSynchronization</code>; however, this isn't free and requires that the developer makes other guarantees that I'll cover later.</p>
<h1 id="some-common-approaches"><a aria-hidden="true" tabindex="-1" href="#some-common-approaches"><span class="icon icon-link"></span></a>Some common approaches</h1>
<p>So, if we decide to marshal collection change events ourselves, how should we do that? One approach is to invoke on the current application's dispatcher directly.</p>
<pre><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ViewModel</span>
{
    <span class="hljs-keyword">public</span> ObservableCollection&#x3C;<span class="hljs-built_in">string</span>> Messages { <span class="hljs-keyword">get</span>; } = [];

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>
    {
        <span class="hljs-keyword">if</span> (Application.Current <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span> || Application.Current.Dispatcher.CheckAccess())
        {
            <span class="hljs-keyword">this</span>.Messages.Add(message);
        }
        <span class="hljs-keyword">else</span>
        {
            _ = Application.Current.Dispatcher.InvokeAsync(
                () => <span class="hljs-keyword">this</span>.Messages.Add(message));
        }
    }
}
</code></pre>
<p>While this is straightforward, it comes with some downsides:</p>
<ul>
<li>The view model is now dependent on <code>System.Windows</code>.</li>
<li>This view model, along with anything else that follows this pattern, will not work for multithreaded UI applications — windows with their own UI thread would have their own <code>Dispatcher</code>.</li>
<li>Similar marshalling needs to occur anywhere <code>Messages</code> is modified.</li>
</ul>
<p>We can get around the first two issues if we're willing to make a tradeoff. The dependency on <code>System.Windows</code> and the current application's dispatcher can be removed if we capture and use the target UI thread's <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext"><code>SynchronizationContext</code></a>.</p>
<aside><p><strong>How can we use a <code>SynchronizationContext</code> in place of a <code>Dispatcher</code>?</strong> In WPF applications, posting or sending delegates with a UI thread's <code>SynchronizationContext.Current</code> queues them to the corresponding thread's <code>Dispatcher.Current</code> with default priority. If we don't need to tune our implementation for UI responsiveness, then using a <code>SynchronizationContext</code> allows our implementation to be more general (i.e., not tied to <code>System.Windows</code>) and simpler. If we need to have more control, we could use a <code>Dispatcher</code> directly instead.</p></aside>
<p>Capturing a <code>SynchronizationContext</code> can either be done:</p>
<ul>
<li>Upon creating the view model, which requires that we guarantee the view model is created on the target UI thread.</li>
<li>Elsewhere in our application, again on the target UI thread, with our view model requiring we it provide the captured reference.</li>
</ul>
<p>Our view model could look something like this:</p>
<pre><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ViewModel</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> SynchronizationContext sc;

    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span></span>
    <span class="hljs-comment">// We *must* be on the UI thread at this point, otherwise we'll</span>
    <span class="hljs-comment">// dispatch operations to a non-UI thread! Being on the UI thread</span>
    <span class="hljs-comment">// also allows us to assume the SynchronizationContext exists,</span>
    <span class="hljs-comment">// which is not guaranteed for any arbitrary thread.</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ViewModel</span>() : <span class="hljs-title">this</span>(<span class="hljs-params">SynchronizationContext.Current!</span>)</span> { }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ViewModel</span>(<span class="hljs-params">SynchronizationContext sc</span>)</span>
    {
        <span class="hljs-keyword">this</span>.sc = sc;
    }

    <span class="hljs-keyword">public</span> ObservableCollection&#x3C;<span class="hljs-built_in">string</span>> Messages { <span class="hljs-keyword">get</span>; } = [];

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sc == SynchronizationContext.Current)
        {
            <span class="hljs-keyword">this</span>.Messages.Add(message);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">this</span>.sc.Post(<span class="hljs-keyword">this</span>.AddMessageCallback!, message);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddMessageCallback</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> message</span>)</span>
    {
        <span class="hljs-keyword">this</span>.Messages.Add((<span class="hljs-built_in">string</span>)message);
    }
}
</code></pre>
<p>The biggest tradeoff with these approaches is something I've explicitly called out multiple times: we have to be on the target UI thread when capturing the <code>SynchronizationContext</code> or <code>Dispatcher</code>. If we're willing to accept that tradeoff (spoiler: <a href="#my-preferred-solution">we don't necessarily have to</a>), we can get around the third issue I mentioned above as well — namely, needing similar marshalling anywhere <code>Messages</code> is used — by creating a subclass of <code>ObservableCollection&#x3C;T></code> that marshals change events for us.</p>
<pre><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObservableCollection</span>&#x3C;<span class="hljs-title">T</span>> : <span class="hljs-title">ObservableCollection</span>&#x3C;<span class="hljs-title">T</span>>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> SynchronizationContext sc;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SynchronizedObservableCollection</span>()
        : <span class="hljs-title">this</span>(<span class="hljs-params">SynchronizationContext.Current!</span>)</span> { }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SynchronizedObservableCollection</span>(<span class="hljs-params">SynchronizationContext sc</span>)</span>
    {
        <span class="hljs-keyword">this</span>.sc = sc;
    }

    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// other ObservableCollection&#x3C;T> constructors</span>
    <span class="hljs-comment">// and SynchronizationContext overloads</span>
    <span class="hljs-comment">// ...</span>

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollectionChanged</span>(<span class="hljs-params">NotifyCollectionChangedEventArgs e</span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sc == SynchronizationContext.Current)
        {
            <span class="hljs-keyword">base</span>.OnCollectionChanged(e);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">this</span>.sc.Send(OnCollectionChangedCallback!, e);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollectionChangedCallback</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> e</span>)</span>
    {
        <span class="hljs-keyword">base</span>.OnCollectionChanged((NotifyCollectionChangedEventArgs)e);
    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPropertyChanged</span>(<span class="hljs-params">PropertyChangedEventArgs e</span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sc == SynchronizationContext.Current)
        {
            <span class="hljs-keyword">base</span>.OnPropertyChanged(e);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">this</span>.sc.Send(OnPropertyChangedCallback!, e);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPropertyChangedCallback</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> e</span>)</span>
    {
        <span class="hljs-keyword">base</span>.OnPropertyChanged((PropertyChangedEventArgs)e);
    }
}
</code></pre>
<p>With this new collection, our view model becomes:</p>
<pre><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ViewModel</span>
{
    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span></span>
    <span class="hljs-comment">// Like before, we *must* be on the UI thread at this point.</span>
    <span class="hljs-keyword">public</span> SynchronizedObservableCollection&#x3C;<span class="hljs-built_in">string</span>> Messages { <span class="hljs-keyword">get</span>; } = [];

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>
    {
        <span class="hljs-keyword">this</span>.Messages.Add(message);
    }
}
</code></pre>
<p>There is a subtle, but very important, difference between the new subclass and the previous implementation. Because the entire <code>Add</code> operation, including both adding the item and raising change events, on the <code>Messages</code> collection was previously marshalled to the UI thread, <code>AddMessage</code> was effectively thread-safe. Now, <code>AddMessage</code> can still be called from a background thread, but it is not thread-safe — multiple threads calling it at approximately the same time could result in an exception due to collection modifications before the UI can finish processing a previous change event. This is also why the subclass calls the <code>SynchronizationContext</code>'s synchronous <code>Send</code> method instead of <code>Post</code>. We have to ensure the UI can finish processing change events before modifying the collection again.</p>
<p>At this point, we could consider ways to make our new collection thread-safe for modifications. For example, we could override every <code>ObservableCollection&#x3C;T></code> modification method and queue operations on the UI thread. We could also change our approach and stop marshalling collection changes ourselves.</p>
<aside><p>Another solution that I'm not going to discuss in detail is akin to what I cover below. In short, we could maintain two copies of the collection, a thread-safe collection that queues changes to another UI-bound collection, which processes queued changes on the UI thread. This is better explained and demonstrated <a href="https://www.meziantou.net/thread-safe-observable-collection-in-dotnet.htm">here</a>.</p><p><strong>Bonus:</strong> The collection in the linked post uses an <code>ImmutableList&#x3C;T></code> behind the scenes, so it can be safely enumerated without additional synchronization.</p></aside>
<p>WPF provides a mechanism that allows collection changes to occur on background threads provided the developer makes some guarantees: <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.bindingoperations.enablecollectionsynchronization"><code>BindingOperations.EnableCollectionSynchronization</code></a>. When this is called on a UI-bound collection, WPF effectively queues up change events and processes changes on the UI thread. The required guarantees are:</p>
<ul>
<li>The method must be called on the target UI thread.</li>
<li>Modifications and access to the collection must be synchronized to ensure the collection is not modified while the UI thread is accessing it.</li>
</ul>
<p>Synchronization can be as simple as acquiring a lock, although the API allows for more sophisticated synchronization. Using this method our view model can go back to using the standard <code>ObservableCollection&#x3C;T></code>.</p>
<pre><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ViewModel</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> messageLock = <span class="hljs-keyword">new</span>();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ViewModel</span>()</span>
    {
        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span></span>
        <span class="hljs-comment">// We still *must* be on the UI thread!</span>
        BindingOperations.EnableCollectionSynchronization(
            <span class="hljs-keyword">this</span>.Messages, <span class="hljs-keyword">this</span>.messageLock);
    }

    <span class="hljs-keyword">public</span> ObservableCollection&#x3C;<span class="hljs-built_in">string</span>> Messages { <span class="hljs-keyword">get</span>; } = [];

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>
    {
        <span class="hljs-keyword">lock</span> (<span class="hljs-keyword">this</span>.messageLock)
        {
            <span class="hljs-keyword">this</span>.Messages.Add(message);
        }
    }
}
</code></pre>
<p>This has similar downsides the other implementations covered so far:</p>
<ul>
<li>The view model is now dependent on <code>System.Windows.Data</code>.</li>
<li>The view model must be created on the target UI thread.</li>
<li>Similar synchronization needs to occur anywhere <code>Messages</code> is modified.</li>
</ul>
<p>With a few changes, though, we can mitigate all of these downsides.</p>
<h1 id="my-preferred-solution"><a aria-hidden="true" tabindex="-1" href="#my-preferred-solution"><span class="icon icon-link"></span></a>My preferred solution</h1>
<p>We've already shown a subclass can be used to avoid explicit call-site synchronization when modifying an <code>ObservableCollection&#x3C;T></code>.</p>
<pre><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ISynchronized</span>
{
    <span class="hljs-built_in">object</span> SynchronizationLock { <span class="hljs-keyword">get</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObservableCollection</span>&#x3C;<span class="hljs-title">T</span>> 
    : <span class="hljs-title">ObservableCollection</span>&#x3C;<span class="hljs-title">T</span>>, <span class="hljs-title">ISynchronized</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> syncLock;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SynchronizedObservableCollection</span>()
        : <span class="hljs-title">this</span>(<span class="hljs-params"><span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>(</span>))</span> { }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SynchronizedObservableCollection</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> syncLock</span>)</span>
    {
        <span class="hljs-keyword">this</span>.syncLock = syncLock;
    }

    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// other ObservableCollection&#x3C;T> constructors</span>
    <span class="hljs-comment">// and syncLock overloads</span>
    <span class="hljs-comment">// ...</span>

    <span class="hljs-built_in">object</span> ISynchronized.SynchronizationLock => <span class="hljs-keyword">this</span>.syncLock;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InsertItem</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, T item</span>)</span>
    {
        <span class="hljs-keyword">lock</span> (<span class="hljs-keyword">this</span>.syncLock)
        {
            <span class="hljs-keyword">base</span>.InsertItem(index, item);
        }
    }

    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// other synchronized modification overloads</span>
    <span class="hljs-comment">// ...</span>

    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&#x3C;inheritdoc cref="Collection{T}.Add(T)"/></span></span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UnsyncAdd</span>(<span class="hljs-params">T item</span>)</span>
    {
        <span class="hljs-keyword">base</span>.InsertItem(<span class="hljs-keyword">this</span>.Count, item);
    }

    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// other modification escape hatch methods that leave</span>
    <span class="hljs-comment">// synchronization up to the caller</span>
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>Notice that this collection subclass implements a new <code>ISynchronized</code> interface. Our view model no longer needs to synchronize modifications explicitly.</p>
<pre><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ViewModel</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ViewModel</span>()</span>
    {
        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span></span>
        <span class="hljs-comment">// We still *must* be on the UI thread!</span>
        BindingOperations.EnableCollectionSynchronization(
            <span class="hljs-keyword">this</span>.Messages,
            ((ISynchronized)<span class="hljs-keyword">this</span>.Messages).SynchronizationLock);
    }

    <span class="hljs-keyword">public</span> SynchronizedObservableCollection&#x3C;<span class="hljs-built_in">string</span>> Messages { <span class="hljs-keyword">get</span>; } = [];

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>
    {
        <span class="hljs-keyword">this</span>.Messages.Add(message);
    }
}
</code></pre>
<p>We still have the problem of our view model needing to be created on the target UI thread. There is a way to allow our view model to be created on any thread and still leverage WPF's built-in collection synchronization: an <a href="https://learn.microsoft.com/en-us/dotnet/desktop/wpf/properties/attached-properties-overview">attached property</a>. Attached properties are always evaluated on the UI thread, so we can use them to defer collection synchronization until the UI first binds to our collection.</p>
<pre><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Synchronized</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DependencyProperty ItemsSourceProperty =
        DependencyProperty.RegisterAttached(
            <span class="hljs-string">"ItemsSource"</span>,
            <span class="hljs-keyword">typeof</span>(IEnumerable),
            <span class="hljs-keyword">typeof</span>(Synchronized),
            <span class="hljs-keyword">new</span> PropertyMetadata(<span class="hljs-literal">null</span>, OnItemsSourceChanged));

    [<span class="hljs-meta">AttachedPropertyBrowsableForType(typeof(ItemsControl))</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IEnumerable <span class="hljs-title">GetItemsSource</span>(<span class="hljs-params">DependencyObject target</span>)</span>
        => (IEnumerable)target.GetValue(ItemsSourceProperty);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetItemsSource</span>(<span class="hljs-params">DependencyObject target, IEnumerable <span class="hljs-keyword">value</span></span>)</span>
        => target.SetValue(ItemsSourceProperty, <span class="hljs-keyword">value</span>);

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnItemsSourceChanged</span>(<span class="hljs-params">
        DependencyObject d,
        DependencyPropertyChangedEventArgs e</span>)</span>
    {
        <span class="hljs-keyword">var</span> ic = (ItemsControl)d;

        <span class="hljs-keyword">if</span> (e.NewValue <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>)
        {
            ic.ItemsSource = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> newItemsSource = (IEnumerable)e.NewValue;

        IEnumerable synchronizedItemsSource = newItemsSource <span class="hljs-keyword">is</span> ICollectionView cv
            ? cv.SourceCollection : newItemsSource;

        <span class="hljs-keyword">var</span> synchronized = synchronizedItemsSource <span class="hljs-keyword">as</span> ISynchronized
            ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(
                <span class="hljs-string">$"Cannot synchronize access to items in source collection of type "</span> +
                <span class="hljs-string">$"'<span class="hljs-subst">{synchronizedItemsSource.GetType()}</span>' because it does not implement "</span> +
                <span class="hljs-string">$"'<span class="hljs-subst">{<span class="hljs-keyword">nameof</span>(ISynchronized)}</span>'."</span>);

        BindingOperations.EnableCollectionSynchronization(
            synchronizedItemsSource,
            synchronized.SynchronizationLock);

        ic.ItemsSource = newItemsSource;
    }
}
</code></pre>
<p>Putting everything together, our view model becomes:</p>
<pre><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ViewModel</span>
{
    <span class="hljs-keyword">public</span> SynchronizedObservableCollection&#x3C;<span class="hljs-built_in">string</span>> Messages { <span class="hljs-keyword">get</span>; } = [];

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>
    {
        <span class="hljs-keyword">this</span>.Messages.Add(message);
    }
}
</code></pre>
<p>While our UI's XAML starts using the attached property instead of <code>ItemsSource</code> properties directly:</p>
<pre><code class="hljs language-xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">"Examples.MainWindow"</span>
        <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
        <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml"</span>
        <span class="hljs-attr">xmlns:d</span>=<span class="hljs-string">"http://schemas.microsoft.com/expression/blend/2008"</span>
        <span class="hljs-attr">xmlns:mc</span>=<span class="hljs-string">"http://schemas.openxmlformats.org/markup-compatibility/2006"</span>
        <span class="hljs-attr">xmlns:local</span>=<span class="hljs-string">"clr-namespace:Examples"</span>
        <span class="hljs-attr">xmlns:csm</span>=<span class="hljs-string">"clr-namespace:CsmLib.Wpf.Controls;assembly=CsmLib.Wpf"</span>
        <span class="hljs-attr">mc:Ignorable</span>=<span class="hljs-string">"d"</span>
        <span class="hljs-attr">d:DataContext</span>=<span class="hljs-string">"{d:DesignInstance local:ViewModel}"</span>
        <span class="hljs-attr">Title</span>=<span class="hljs-string">"Example"</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">"450"</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">"800"</span>></span>

    <span class="hljs-comment">&#x3C;!-- before: &#x3C;ListBox ItemsSource="{Binding Messages}"/>--></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">ListBox</span> <span class="hljs-attr">csm:Synchronized.ItemsSource</span>=<span class="hljs-string">"{Binding Messages}"</span>/></span>

<span class="hljs-tag">&#x3C;/<span class="hljs-name">Window</span>></span>
</code></pre>
<p>Now our observable collection is thread-safe for modifications, and we don't have to consider the UI thread outside of data binding.</p>
<p>You can find full source code and an accompanying example <a href="https://github.com/tadmccorkle/CsmLib">here</a>.</p><!-- HTML_TAG_END --> </article></main> <footer class="svelte-j2m7nr"><span id="footer-copyright" class="svelte-j2m7nr"><div>Copyright © 2025 Tad McCorkle</div> <div data-svelte-h="svelte-z6584h"><a href="https://github.com/tadmccorkle/tadmccorkle.github.io/blob/master/LICENSE">All code is under MIT license</a></div></span> <span id="footer-links" class="svelte-j2m7nr" data-svelte-h="svelte-9ox39f"><a href="https://github.com/tadmccorkle" class="svelte-j2m7nr">github</a>
		•
		<a href="/feed.xml" target="_blank" rel="noopener noreferrer" class="svelte-j2m7nr">feed</a></span> </footer> 
			
			<script>
				{
					__sveltekit_1npdyvp = {
						base: new URL("../..", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("../../_app/immutable/entry/start.CRnMxn2k.js"),
						import("../../_app/immutable/entry/app.Bm8EiCMo.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 4],
							data: [null,{type:"data",data:{post:{metadata:{title:"Simplifying Collection Usage in Multithreaded WPF",date:new Date(1747051200000),excerpt:"A convenient way to avoid issues with observable collections in multithreaded WPF applications."},content:"\u003Cp>Data binding in WPF makes updating the UI in response to changes easy, so long as the UI is notified of changes by way of the \u003Ccode>INotifyPropertyChanged\u003C/code> or \u003Ccode>INotifyCollectionChanged\u003C/code> interface change events. For scalar properties, this is true even when an update is triggered from a background thread — the binding engine handles the property change by marshalling it (i.e., queuing a corresponding delegate) to the appropriate UI thread's dispatcher. While there's no manual marshalling or synchronization required by the application developer for scalar property updates, you'll quickly discover that this is \u003Cstrong>not\u003C/strong> the case when binding an \u003Ccode>ItemControl\u003C/code>'s \u003Ccode>ItemsSource\u003C/code> to a dynamic collection. In fact, manual marshalling to the UI thread or additional synchronization is absolutely required in a multithreaded context.\u003C/p>\n\u003Caside>\u003Cp>\u003Cstrong>tl;dr\u003C/strong> I've been using \u003Ca href=\"#my-preferred-solution\">a simple solution\u003C/a> to the issue of multithreaded collection modification in WPF that avoids many of the tradeoffs in approaches I've seen referenced. You can see it in action \u003Ca href=\"https://github.com/tadmccorkle/CsmLib\">here\u003C/a>.\u003C/p>\u003C/aside>\n\u003Ch1 id=\"why-are-collections-treated-differently\">\u003Ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#why-are-collections-treated-differently\">\u003Cspan class=\"icon icon-link\">\u003C/span>\u003C/a>Why are collections treated differently?\u003C/h1>\n\u003Cp>Without getting too deep in the weeds, this is due to how WPF handles collection bindings. WPF uses a type called \u003Ccode>CollectionView\u003C/code> to access a bound collection. Any given \u003Ccode>CollectionView\u003C/code> has affinity to the thread that created its corresponding \u003Ccode>ItemsControl\u003C/code>, meaning it requires its operations to occur on that thread. By default, if a \u003Ccode>CollectionView\u003C/code> operation is initiated from a background thread — for example, by adding to a UI-bound \u003Ccode>ObservableCollection&#x3C;T>\u003C/code> — the \u003Ccode>CollectionView\u003C/code> will throw an exception.\u003C/p>\n\u003Cp>Notice I said this \u003Ccode>CollectionView\u003C/code> behavior is \"by default.\" WPF does provide a mechanism to allow collection changes on background threads through \u003Ccode>BindingOperations.EnableCollectionSynchronization\u003C/code>; however, this isn't free and requires that the developer makes other guarantees that I'll cover later.\u003C/p>\n\u003Ch1 id=\"some-common-approaches\">\u003Ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#some-common-approaches\">\u003Cspan class=\"icon icon-link\">\u003C/span>\u003C/a>Some common approaches\u003C/h1>\n\u003Cp>So, if we decide to marshal collection change events ourselves, how should we do that? One approach is to invoke on the current application's dispatcher directly.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-csharp\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">class\u003C/span> \u003Cspan class=\"hljs-title\">ViewModel\u003C/span>\n{\n    \u003Cspan class=\"hljs-keyword\">public\u003C/span> ObservableCollection&#x3C;\u003Cspan class=\"hljs-built_in\">string\u003C/span>> Messages { \u003Cspan class=\"hljs-keyword\">get\u003C/span>; } = [];\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">void\u003C/span> \u003Cspan class=\"hljs-title\">AddMessage\u003C/span>(\u003Cspan class=\"hljs-params\">\u003Cspan class=\"hljs-built_in\">string\u003C/span> message\u003C/span>)\u003C/span>\n    {\n        \u003Cspan class=\"hljs-keyword\">if\u003C/span> (Application.Current \u003Cspan class=\"hljs-keyword\">is\u003C/span> \u003Cspan class=\"hljs-literal\">null\u003C/span> || Application.Current.Dispatcher.CheckAccess())\n        {\n            \u003Cspan class=\"hljs-keyword\">this\u003C/span>.Messages.Add(message);\n        }\n        \u003Cspan class=\"hljs-keyword\">else\u003C/span>\n        {\n            _ = Application.Current.Dispatcher.InvokeAsync(\n                () => \u003Cspan class=\"hljs-keyword\">this\u003C/span>.Messages.Add(message));\n        }\n    }\n}\n\u003C/code>\u003C/pre>\n\u003Cp>While this is straightforward, it comes with some downsides:\u003C/p>\n\u003Cul>\n\u003Cli>The view model is now dependent on \u003Ccode>System.Windows\u003C/code>.\u003C/li>\n\u003Cli>This view model, along with anything else that follows this pattern, will not work for multithreaded UI applications — windows with their own UI thread would have their own \u003Ccode>Dispatcher\u003C/code>.\u003C/li>\n\u003Cli>Similar marshalling needs to occur anywhere \u003Ccode>Messages\u003C/code> is modified.\u003C/li>\n\u003C/ul>\n\u003Cp>We can get around the first two issues if we're willing to make a tradeoff. The dependency on \u003Ccode>System.Windows\u003C/code> and the current application's dispatcher can be removed if we capture and use the target UI thread's \u003Ca href=\"https://learn.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext\">\u003Ccode>SynchronizationContext\u003C/code>\u003C/a>.\u003C/p>\n\u003Caside>\u003Cp>\u003Cstrong>How can we use a \u003Ccode>SynchronizationContext\u003C/code> in place of a \u003Ccode>Dispatcher\u003C/code>?\u003C/strong> In WPF applications, posting or sending delegates with a UI thread's \u003Ccode>SynchronizationContext.Current\u003C/code> queues them to the corresponding thread's \u003Ccode>Dispatcher.Current\u003C/code> with default priority. If we don't need to tune our implementation for UI responsiveness, then using a \u003Ccode>SynchronizationContext\u003C/code> allows our implementation to be more general (i.e., not tied to \u003Ccode>System.Windows\u003C/code>) and simpler. If we need to have more control, we could use a \u003Ccode>Dispatcher\u003C/code> directly instead.\u003C/p>\u003C/aside>\n\u003Cp>Capturing a \u003Ccode>SynchronizationContext\u003C/code> can either be done:\u003C/p>\n\u003Cul>\n\u003Cli>Upon creating the view model, which requires that we guarantee the view model is created on the target UI thread.\u003C/li>\n\u003Cli>Elsewhere in our application, again on the target UI thread, with our view model requiring we it provide the captured reference.\u003C/li>\n\u003C/ul>\n\u003Cp>Our view model could look something like this:\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-csharp\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">class\u003C/span> \u003Cspan class=\"hljs-title\">ViewModel\u003C/span>\n{\n    \u003Cspan class=\"hljs-keyword\">private\u003C/span> \u003Cspan class=\"hljs-keyword\">readonly\u003C/span> SynchronizationContext sc;\n\n    \u003Cspan class=\"hljs-comment\">// \u003Cspan class=\"hljs-doctag\">NOTE:\u003C/span>\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// We *must* be on the UI thread at this point, otherwise we'll\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// dispatch operations to a non-UI thread! Being on the UI thread\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// also allows us to assume the SynchronizationContext exists,\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// which is not guaranteed for any arbitrary thread.\u003C/span>\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-title\">ViewModel\u003C/span>() : \u003Cspan class=\"hljs-title\">this\u003C/span>(\u003Cspan class=\"hljs-params\">SynchronizationContext.Current!\u003C/span>)\u003C/span> { }\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-title\">ViewModel\u003C/span>(\u003Cspan class=\"hljs-params\">SynchronizationContext sc\u003C/span>)\u003C/span>\n    {\n        \u003Cspan class=\"hljs-keyword\">this\u003C/span>.sc = sc;\n    }\n\n    \u003Cspan class=\"hljs-keyword\">public\u003C/span> ObservableCollection&#x3C;\u003Cspan class=\"hljs-built_in\">string\u003C/span>> Messages { \u003Cspan class=\"hljs-keyword\">get\u003C/span>; } = [];\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">void\u003C/span> \u003Cspan class=\"hljs-title\">AddMessage\u003C/span>(\u003Cspan class=\"hljs-params\">\u003Cspan class=\"hljs-built_in\">string\u003C/span> message\u003C/span>)\u003C/span>\n    {\n        \u003Cspan class=\"hljs-keyword\">if\u003C/span> (\u003Cspan class=\"hljs-keyword\">this\u003C/span>.sc == SynchronizationContext.Current)\n        {\n            \u003Cspan class=\"hljs-keyword\">this\u003C/span>.Messages.Add(message);\n        }\n        \u003Cspan class=\"hljs-keyword\">else\u003C/span>\n        {\n            \u003Cspan class=\"hljs-keyword\">this\u003C/span>.sc.Post(\u003Cspan class=\"hljs-keyword\">this\u003C/span>.AddMessageCallback!, message);\n        }\n    }\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">private\u003C/span> \u003Cspan class=\"hljs-keyword\">void\u003C/span> \u003Cspan class=\"hljs-title\">AddMessageCallback\u003C/span>(\u003Cspan class=\"hljs-params\">\u003Cspan class=\"hljs-built_in\">object\u003C/span> message\u003C/span>)\u003C/span>\n    {\n        \u003Cspan class=\"hljs-keyword\">this\u003C/span>.Messages.Add((\u003Cspan class=\"hljs-built_in\">string\u003C/span>)message);\n    }\n}\n\u003C/code>\u003C/pre>\n\u003Cp>The biggest tradeoff with these approaches is something I've explicitly called out multiple times: we have to be on the target UI thread when capturing the \u003Ccode>SynchronizationContext\u003C/code> or \u003Ccode>Dispatcher\u003C/code>. If we're willing to accept that tradeoff (spoiler: \u003Ca href=\"#my-preferred-solution\">we don't necessarily have to\u003C/a>), we can get around the third issue I mentioned above as well — namely, needing similar marshalling anywhere \u003Ccode>Messages\u003C/code> is used — by creating a subclass of \u003Ccode>ObservableCollection&#x3C;T>\u003C/code> that marshals change events for us.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-csharp\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">class\u003C/span> \u003Cspan class=\"hljs-title\">SynchronizedObservableCollection\u003C/span>&#x3C;\u003Cspan class=\"hljs-title\">T\u003C/span>> : \u003Cspan class=\"hljs-title\">ObservableCollection\u003C/span>&#x3C;\u003Cspan class=\"hljs-title\">T\u003C/span>>\n{\n    \u003Cspan class=\"hljs-keyword\">private\u003C/span> \u003Cspan class=\"hljs-keyword\">readonly\u003C/span> SynchronizationContext sc;\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-title\">SynchronizedObservableCollection\u003C/span>()\n        : \u003Cspan class=\"hljs-title\">this\u003C/span>(\u003Cspan class=\"hljs-params\">SynchronizationContext.Current!\u003C/span>)\u003C/span> { }\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-title\">SynchronizedObservableCollection\u003C/span>(\u003Cspan class=\"hljs-params\">SynchronizationContext sc\u003C/span>)\u003C/span>\n    {\n        \u003Cspan class=\"hljs-keyword\">this\u003C/span>.sc = sc;\n    }\n\n    \u003Cspan class=\"hljs-comment\">// ...\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// other ObservableCollection&#x3C;T> constructors\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// and SynchronizationContext overloads\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// ...\u003C/span>\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">protected\u003C/span> \u003Cspan class=\"hljs-keyword\">override\u003C/span> \u003Cspan class=\"hljs-keyword\">void\u003C/span> \u003Cspan class=\"hljs-title\">OnCollectionChanged\u003C/span>(\u003Cspan class=\"hljs-params\">NotifyCollectionChangedEventArgs e\u003C/span>)\u003C/span>\n    {\n        \u003Cspan class=\"hljs-keyword\">if\u003C/span> (\u003Cspan class=\"hljs-keyword\">this\u003C/span>.sc == SynchronizationContext.Current)\n        {\n            \u003Cspan class=\"hljs-keyword\">base\u003C/span>.OnCollectionChanged(e);\n        }\n        \u003Cspan class=\"hljs-keyword\">else\u003C/span>\n        {\n            \u003Cspan class=\"hljs-keyword\">this\u003C/span>.sc.Send(OnCollectionChangedCallback!, e);\n        }\n    }\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">private\u003C/span> \u003Cspan class=\"hljs-keyword\">void\u003C/span> \u003Cspan class=\"hljs-title\">OnCollectionChangedCallback\u003C/span>(\u003Cspan class=\"hljs-params\">\u003Cspan class=\"hljs-built_in\">object\u003C/span> e\u003C/span>)\u003C/span>\n    {\n        \u003Cspan class=\"hljs-keyword\">base\u003C/span>.OnCollectionChanged((NotifyCollectionChangedEventArgs)e);\n    }\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">protected\u003C/span> \u003Cspan class=\"hljs-keyword\">override\u003C/span> \u003Cspan class=\"hljs-keyword\">void\u003C/span> \u003Cspan class=\"hljs-title\">OnPropertyChanged\u003C/span>(\u003Cspan class=\"hljs-params\">PropertyChangedEventArgs e\u003C/span>)\u003C/span>\n    {\n        \u003Cspan class=\"hljs-keyword\">if\u003C/span> (\u003Cspan class=\"hljs-keyword\">this\u003C/span>.sc == SynchronizationContext.Current)\n        {\n            \u003Cspan class=\"hljs-keyword\">base\u003C/span>.OnPropertyChanged(e);\n        }\n        \u003Cspan class=\"hljs-keyword\">else\u003C/span>\n        {\n            \u003Cspan class=\"hljs-keyword\">this\u003C/span>.sc.Send(OnPropertyChangedCallback!, e);\n        }\n    }\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">private\u003C/span> \u003Cspan class=\"hljs-keyword\">void\u003C/span> \u003Cspan class=\"hljs-title\">OnPropertyChangedCallback\u003C/span>(\u003Cspan class=\"hljs-params\">\u003Cspan class=\"hljs-built_in\">object\u003C/span> e\u003C/span>)\u003C/span>\n    {\n        \u003Cspan class=\"hljs-keyword\">base\u003C/span>.OnPropertyChanged((PropertyChangedEventArgs)e);\n    }\n}\n\u003C/code>\u003C/pre>\n\u003Cp>With this new collection, our view model becomes:\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-csharp\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">class\u003C/span> \u003Cspan class=\"hljs-title\">ViewModel\u003C/span>\n{\n    \u003Cspan class=\"hljs-comment\">// \u003Cspan class=\"hljs-doctag\">NOTE:\u003C/span>\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// Like before, we *must* be on the UI thread at this point.\u003C/span>\n    \u003Cspan class=\"hljs-keyword\">public\u003C/span> SynchronizedObservableCollection&#x3C;\u003Cspan class=\"hljs-built_in\">string\u003C/span>> Messages { \u003Cspan class=\"hljs-keyword\">get\u003C/span>; } = [];\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">void\u003C/span> \u003Cspan class=\"hljs-title\">AddMessage\u003C/span>(\u003Cspan class=\"hljs-params\">\u003Cspan class=\"hljs-built_in\">string\u003C/span> message\u003C/span>)\u003C/span>\n    {\n        \u003Cspan class=\"hljs-keyword\">this\u003C/span>.Messages.Add(message);\n    }\n}\n\u003C/code>\u003C/pre>\n\u003Cp>There is a subtle, but very important, difference between the new subclass and the previous implementation. Because the entire \u003Ccode>Add\u003C/code> operation, including both adding the item and raising change events, on the \u003Ccode>Messages\u003C/code> collection was previously marshalled to the UI thread, \u003Ccode>AddMessage\u003C/code> was effectively thread-safe. Now, \u003Ccode>AddMessage\u003C/code> can still be called from a background thread, but it is not thread-safe — multiple threads calling it at approximately the same time could result in an exception due to collection modifications before the UI can finish processing a previous change event. This is also why the subclass calls the \u003Ccode>SynchronizationContext\u003C/code>'s synchronous \u003Ccode>Send\u003C/code> method instead of \u003Ccode>Post\u003C/code>. We have to ensure the UI can finish processing change events before modifying the collection again.\u003C/p>\n\u003Cp>At this point, we could consider ways to make our new collection thread-safe for modifications. For example, we could override every \u003Ccode>ObservableCollection&#x3C;T>\u003C/code> modification method and queue operations on the UI thread. We could also change our approach and stop marshalling collection changes ourselves.\u003C/p>\n\u003Caside>\u003Cp>Another solution that I'm not going to discuss in detail is akin to what I cover below. In short, we could maintain two copies of the collection, a thread-safe collection that queues changes to another UI-bound collection, which processes queued changes on the UI thread. This is better explained and demonstrated \u003Ca href=\"https://www.meziantou.net/thread-safe-observable-collection-in-dotnet.htm\">here\u003C/a>.\u003C/p>\u003Cp>\u003Cstrong>Bonus:\u003C/strong> The collection in the linked post uses an \u003Ccode>ImmutableList&#x3C;T>\u003C/code> behind the scenes, so it can be safely enumerated without additional synchronization.\u003C/p>\u003C/aside>\n\u003Cp>WPF provides a mechanism that allows collection changes to occur on background threads provided the developer makes some guarantees: \u003Ca href=\"https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.bindingoperations.enablecollectionsynchronization\">\u003Ccode>BindingOperations.EnableCollectionSynchronization\u003C/code>\u003C/a>. When this is called on a UI-bound collection, WPF effectively queues up change events and processes changes on the UI thread. The required guarantees are:\u003C/p>\n\u003Cul>\n\u003Cli>The method must be called on the target UI thread.\u003C/li>\n\u003Cli>Modifications and access to the collection must be synchronized to ensure the collection is not modified while the UI thread is accessing it.\u003C/li>\n\u003C/ul>\n\u003Cp>Synchronization can be as simple as acquiring a lock, although the API allows for more sophisticated synchronization. Using this method our view model can go back to using the standard \u003Ccode>ObservableCollection&#x3C;T>\u003C/code>.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-csharp\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">class\u003C/span> \u003Cspan class=\"hljs-title\">ViewModel\u003C/span>\n{\n    \u003Cspan class=\"hljs-keyword\">private\u003C/span> \u003Cspan class=\"hljs-keyword\">readonly\u003C/span> \u003Cspan class=\"hljs-built_in\">object\u003C/span> messageLock = \u003Cspan class=\"hljs-keyword\">new\u003C/span>();\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-title\">ViewModel\u003C/span>()\u003C/span>\n    {\n        \u003Cspan class=\"hljs-comment\">// \u003Cspan class=\"hljs-doctag\">NOTE:\u003C/span>\u003C/span>\n        \u003Cspan class=\"hljs-comment\">// We still *must* be on the UI thread!\u003C/span>\n        BindingOperations.EnableCollectionSynchronization(\n            \u003Cspan class=\"hljs-keyword\">this\u003C/span>.Messages, \u003Cspan class=\"hljs-keyword\">this\u003C/span>.messageLock);\n    }\n\n    \u003Cspan class=\"hljs-keyword\">public\u003C/span> ObservableCollection&#x3C;\u003Cspan class=\"hljs-built_in\">string\u003C/span>> Messages { \u003Cspan class=\"hljs-keyword\">get\u003C/span>; } = [];\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">void\u003C/span> \u003Cspan class=\"hljs-title\">AddMessage\u003C/span>(\u003Cspan class=\"hljs-params\">\u003Cspan class=\"hljs-built_in\">string\u003C/span> message\u003C/span>)\u003C/span>\n    {\n        \u003Cspan class=\"hljs-keyword\">lock\u003C/span> (\u003Cspan class=\"hljs-keyword\">this\u003C/span>.messageLock)\n        {\n            \u003Cspan class=\"hljs-keyword\">this\u003C/span>.Messages.Add(message);\n        }\n    }\n}\n\u003C/code>\u003C/pre>\n\u003Cp>This has similar downsides the other implementations covered so far:\u003C/p>\n\u003Cul>\n\u003Cli>The view model is now dependent on \u003Ccode>System.Windows.Data\u003C/code>.\u003C/li>\n\u003Cli>The view model must be created on the target UI thread.\u003C/li>\n\u003Cli>Similar synchronization needs to occur anywhere \u003Ccode>Messages\u003C/code> is modified.\u003C/li>\n\u003C/ul>\n\u003Cp>With a few changes, though, we can mitigate all of these downsides.\u003C/p>\n\u003Ch1 id=\"my-preferred-solution\">\u003Ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#my-preferred-solution\">\u003Cspan class=\"icon icon-link\">\u003C/span>\u003C/a>My preferred solution\u003C/h1>\n\u003Cp>We've already shown a subclass can be used to avoid explicit call-site synchronization when modifying an \u003Ccode>ObservableCollection&#x3C;T>\u003C/code>.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-csharp\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">interface\u003C/span> \u003Cspan class=\"hljs-title\">ISynchronized\u003C/span>\n{\n    \u003Cspan class=\"hljs-built_in\">object\u003C/span> SynchronizationLock { \u003Cspan class=\"hljs-keyword\">get\u003C/span>; }\n}\n\n\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">class\u003C/span> \u003Cspan class=\"hljs-title\">SynchronizedObservableCollection\u003C/span>&#x3C;\u003Cspan class=\"hljs-title\">T\u003C/span>> \n    : \u003Cspan class=\"hljs-title\">ObservableCollection\u003C/span>&#x3C;\u003Cspan class=\"hljs-title\">T\u003C/span>>, \u003Cspan class=\"hljs-title\">ISynchronized\u003C/span>\n{\n    \u003Cspan class=\"hljs-keyword\">private\u003C/span> \u003Cspan class=\"hljs-keyword\">readonly\u003C/span> \u003Cspan class=\"hljs-built_in\">object\u003C/span> syncLock;\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-title\">SynchronizedObservableCollection\u003C/span>()\n        : \u003Cspan class=\"hljs-title\">this\u003C/span>(\u003Cspan class=\"hljs-params\">\u003Cspan class=\"hljs-keyword\">new\u003C/span> \u003Cspan class=\"hljs-built_in\">object\u003C/span>(\u003C/span>))\u003C/span> { }\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-title\">SynchronizedObservableCollection\u003C/span>(\u003Cspan class=\"hljs-params\">\u003Cspan class=\"hljs-built_in\">object\u003C/span> syncLock\u003C/span>)\u003C/span>\n    {\n        \u003Cspan class=\"hljs-keyword\">this\u003C/span>.syncLock = syncLock;\n    }\n\n    \u003Cspan class=\"hljs-comment\">// ...\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// other ObservableCollection&#x3C;T> constructors\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// and syncLock overloads\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// ...\u003C/span>\n\n    \u003Cspan class=\"hljs-built_in\">object\u003C/span> ISynchronized.SynchronizationLock => \u003Cspan class=\"hljs-keyword\">this\u003C/span>.syncLock;\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">protected\u003C/span> \u003Cspan class=\"hljs-keyword\">override\u003C/span> \u003Cspan class=\"hljs-keyword\">void\u003C/span> \u003Cspan class=\"hljs-title\">InsertItem\u003C/span>(\u003Cspan class=\"hljs-params\">\u003Cspan class=\"hljs-built_in\">int\u003C/span> index, T item\u003C/span>)\u003C/span>\n    {\n        \u003Cspan class=\"hljs-keyword\">lock\u003C/span> (\u003Cspan class=\"hljs-keyword\">this\u003C/span>.syncLock)\n        {\n            \u003Cspan class=\"hljs-keyword\">base\u003C/span>.InsertItem(index, item);\n        }\n    }\n\n    \u003Cspan class=\"hljs-comment\">// ...\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// other synchronized modification overloads\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// ...\u003C/span>\n\n    \u003Cspan class=\"hljs-comment\">\u003Cspan class=\"hljs-doctag\">///\u003C/span> \u003Cspan class=\"hljs-doctag\">&#x3C;inheritdoc cref=\"Collection{T}.Add(T)\"/>\u003C/span>\u003C/span>\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">void\u003C/span> \u003Cspan class=\"hljs-title\">UnsyncAdd\u003C/span>(\u003Cspan class=\"hljs-params\">T item\u003C/span>)\u003C/span>\n    {\n        \u003Cspan class=\"hljs-keyword\">base\u003C/span>.InsertItem(\u003Cspan class=\"hljs-keyword\">this\u003C/span>.Count, item);\n    }\n\n    \u003Cspan class=\"hljs-comment\">// ...\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// other modification escape hatch methods that leave\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// synchronization up to the caller\u003C/span>\n    \u003Cspan class=\"hljs-comment\">// ...\u003C/span>\n}\n\u003C/code>\u003C/pre>\n\u003Cp>Notice that this collection subclass implements a new \u003Ccode>ISynchronized\u003C/code> interface. Our view model no longer needs to synchronize modifications explicitly.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-csharp\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">class\u003C/span> \u003Cspan class=\"hljs-title\">ViewModel\u003C/span>\n{\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-title\">ViewModel\u003C/span>()\u003C/span>\n    {\n        \u003Cspan class=\"hljs-comment\">// \u003Cspan class=\"hljs-doctag\">NOTE:\u003C/span>\u003C/span>\n        \u003Cspan class=\"hljs-comment\">// We still *must* be on the UI thread!\u003C/span>\n        BindingOperations.EnableCollectionSynchronization(\n            \u003Cspan class=\"hljs-keyword\">this\u003C/span>.Messages,\n            ((ISynchronized)\u003Cspan class=\"hljs-keyword\">this\u003C/span>.Messages).SynchronizationLock);\n    }\n\n    \u003Cspan class=\"hljs-keyword\">public\u003C/span> SynchronizedObservableCollection&#x3C;\u003Cspan class=\"hljs-built_in\">string\u003C/span>> Messages { \u003Cspan class=\"hljs-keyword\">get\u003C/span>; } = [];\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">void\u003C/span> \u003Cspan class=\"hljs-title\">AddMessage\u003C/span>(\u003Cspan class=\"hljs-params\">\u003Cspan class=\"hljs-built_in\">string\u003C/span> message\u003C/span>)\u003C/span>\n    {\n        \u003Cspan class=\"hljs-keyword\">this\u003C/span>.Messages.Add(message);\n    }\n}\n\u003C/code>\u003C/pre>\n\u003Cp>We still have the problem of our view model needing to be created on the target UI thread. There is a way to allow our view model to be created on any thread and still leverage WPF's built-in collection synchronization: an \u003Ca href=\"https://learn.microsoft.com/en-us/dotnet/desktop/wpf/properties/attached-properties-overview\">attached property\u003C/a>. Attached properties are always evaluated on the UI thread, so we can use them to defer collection synchronization until the UI first binds to our collection.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-csharp\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">static\u003C/span> \u003Cspan class=\"hljs-keyword\">class\u003C/span> \u003Cspan class=\"hljs-title\">Synchronized\u003C/span>\n{\n    \u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">static\u003C/span> \u003Cspan class=\"hljs-keyword\">readonly\u003C/span> DependencyProperty ItemsSourceProperty =\n        DependencyProperty.RegisterAttached(\n            \u003Cspan class=\"hljs-string\">\"ItemsSource\"\u003C/span>,\n            \u003Cspan class=\"hljs-keyword\">typeof\u003C/span>(IEnumerable),\n            \u003Cspan class=\"hljs-keyword\">typeof\u003C/span>(Synchronized),\n            \u003Cspan class=\"hljs-keyword\">new\u003C/span> PropertyMetadata(\u003Cspan class=\"hljs-literal\">null\u003C/span>, OnItemsSourceChanged));\n\n    [\u003Cspan class=\"hljs-meta\">AttachedPropertyBrowsableForType(typeof(ItemsControl))\u003C/span>]\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">static\u003C/span> IEnumerable \u003Cspan class=\"hljs-title\">GetItemsSource\u003C/span>(\u003Cspan class=\"hljs-params\">DependencyObject target\u003C/span>)\u003C/span>\n        => (IEnumerable)target.GetValue(ItemsSourceProperty);\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">static\u003C/span> \u003Cspan class=\"hljs-keyword\">void\u003C/span> \u003Cspan class=\"hljs-title\">SetItemsSource\u003C/span>(\u003Cspan class=\"hljs-params\">DependencyObject target, IEnumerable \u003Cspan class=\"hljs-keyword\">value\u003C/span>\u003C/span>)\u003C/span>\n        => target.SetValue(ItemsSourceProperty, \u003Cspan class=\"hljs-keyword\">value\u003C/span>);\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">private\u003C/span> \u003Cspan class=\"hljs-keyword\">static\u003C/span> \u003Cspan class=\"hljs-keyword\">void\u003C/span> \u003Cspan class=\"hljs-title\">OnItemsSourceChanged\u003C/span>(\u003Cspan class=\"hljs-params\">\n        DependencyObject d,\n        DependencyPropertyChangedEventArgs e\u003C/span>)\u003C/span>\n    {\n        \u003Cspan class=\"hljs-keyword\">var\u003C/span> ic = (ItemsControl)d;\n\n        \u003Cspan class=\"hljs-keyword\">if\u003C/span> (e.NewValue \u003Cspan class=\"hljs-keyword\">is\u003C/span> \u003Cspan class=\"hljs-literal\">null\u003C/span>)\n        {\n            ic.ItemsSource = \u003Cspan class=\"hljs-literal\">null\u003C/span>;\n            \u003Cspan class=\"hljs-keyword\">return\u003C/span>;\n        }\n\n        \u003Cspan class=\"hljs-keyword\">var\u003C/span> newItemsSource = (IEnumerable)e.NewValue;\n\n        IEnumerable synchronizedItemsSource = newItemsSource \u003Cspan class=\"hljs-keyword\">is\u003C/span> ICollectionView cv\n            ? cv.SourceCollection : newItemsSource;\n\n        \u003Cspan class=\"hljs-keyword\">var\u003C/span> synchronized = synchronizedItemsSource \u003Cspan class=\"hljs-keyword\">as\u003C/span> ISynchronized\n            ?? \u003Cspan class=\"hljs-keyword\">throw\u003C/span> \u003Cspan class=\"hljs-keyword\">new\u003C/span> ArgumentException(\n                \u003Cspan class=\"hljs-string\">$\"Cannot synchronize access to items in source collection of type \"\u003C/span> +\n                \u003Cspan class=\"hljs-string\">$\"'\u003Cspan class=\"hljs-subst\">{synchronizedItemsSource.GetType()}\u003C/span>' because it does not implement \"\u003C/span> +\n                \u003Cspan class=\"hljs-string\">$\"'\u003Cspan class=\"hljs-subst\">{\u003Cspan class=\"hljs-keyword\">nameof\u003C/span>(ISynchronized)}\u003C/span>'.\"\u003C/span>);\n\n        BindingOperations.EnableCollectionSynchronization(\n            synchronizedItemsSource,\n            synchronized.SynchronizationLock);\n\n        ic.ItemsSource = newItemsSource;\n    }\n}\n\u003C/code>\u003C/pre>\n\u003Cp>Putting everything together, our view model becomes:\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-csharp\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">class\u003C/span> \u003Cspan class=\"hljs-title\">ViewModel\u003C/span>\n{\n    \u003Cspan class=\"hljs-keyword\">public\u003C/span> SynchronizedObservableCollection&#x3C;\u003Cspan class=\"hljs-built_in\">string\u003C/span>> Messages { \u003Cspan class=\"hljs-keyword\">get\u003C/span>; } = [];\n\n    \u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">void\u003C/span> \u003Cspan class=\"hljs-title\">AddMessage\u003C/span>(\u003Cspan class=\"hljs-params\">\u003Cspan class=\"hljs-built_in\">string\u003C/span> message\u003C/span>)\u003C/span>\n    {\n        \u003Cspan class=\"hljs-keyword\">this\u003C/span>.Messages.Add(message);\n    }\n}\n\u003C/code>\u003C/pre>\n\u003Cp>While our UI's XAML starts using the attached property instead of \u003Ccode>ItemsSource\u003C/code> properties directly:\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-xml\">\u003Cspan class=\"hljs-tag\">&#x3C;\u003Cspan class=\"hljs-name\">Window\u003C/span> \u003Cspan class=\"hljs-attr\">x:Class\u003C/span>=\u003Cspan class=\"hljs-string\">\"Examples.MainWindow\"\u003C/span>\n        \u003Cspan class=\"hljs-attr\">xmlns\u003C/span>=\u003Cspan class=\"hljs-string\">\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\u003C/span>\n        \u003Cspan class=\"hljs-attr\">xmlns:x\u003C/span>=\u003Cspan class=\"hljs-string\">\"http://schemas.microsoft.com/winfx/2006/xaml\"\u003C/span>\n        \u003Cspan class=\"hljs-attr\">xmlns:d\u003C/span>=\u003Cspan class=\"hljs-string\">\"http://schemas.microsoft.com/expression/blend/2008\"\u003C/span>\n        \u003Cspan class=\"hljs-attr\">xmlns:mc\u003C/span>=\u003Cspan class=\"hljs-string\">\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\u003C/span>\n        \u003Cspan class=\"hljs-attr\">xmlns:local\u003C/span>=\u003Cspan class=\"hljs-string\">\"clr-namespace:Examples\"\u003C/span>\n        \u003Cspan class=\"hljs-attr\">xmlns:csm\u003C/span>=\u003Cspan class=\"hljs-string\">\"clr-namespace:CsmLib.Wpf.Controls;assembly=CsmLib.Wpf\"\u003C/span>\n        \u003Cspan class=\"hljs-attr\">mc:Ignorable\u003C/span>=\u003Cspan class=\"hljs-string\">\"d\"\u003C/span>\n        \u003Cspan class=\"hljs-attr\">d:DataContext\u003C/span>=\u003Cspan class=\"hljs-string\">\"{d:DesignInstance local:ViewModel}\"\u003C/span>\n        \u003Cspan class=\"hljs-attr\">Title\u003C/span>=\u003Cspan class=\"hljs-string\">\"Example\"\u003C/span> \u003Cspan class=\"hljs-attr\">Height\u003C/span>=\u003Cspan class=\"hljs-string\">\"450\"\u003C/span> \u003Cspan class=\"hljs-attr\">Width\u003C/span>=\u003Cspan class=\"hljs-string\">\"800\"\u003C/span>>\u003C/span>\n\n    \u003Cspan class=\"hljs-comment\">&#x3C;!-- before: &#x3C;ListBox ItemsSource=\"{Binding Messages}\"/>-->\u003C/span>\n    \u003Cspan class=\"hljs-tag\">&#x3C;\u003Cspan class=\"hljs-name\">ListBox\u003C/span> \u003Cspan class=\"hljs-attr\">csm:Synchronized.ItemsSource\u003C/span>=\u003Cspan class=\"hljs-string\">\"{Binding Messages}\"\u003C/span>/>\u003C/span>\n\n\u003Cspan class=\"hljs-tag\">&#x3C;/\u003Cspan class=\"hljs-name\">Window\u003C/span>>\u003C/span>\n\u003C/code>\u003C/pre>\n\u003Cp>Now our observable collection is thread-safe for modifications, and we don't have to consider the UI thread outside of data binding.\u003C/p>\n\u003Cp>You can find full source code and an accompanying example \u003Ca href=\"https://github.com/tadmccorkle/CsmLib\">here\u003C/a>.\u003C/p>"}},uses:{params:["slug"]}}],
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
